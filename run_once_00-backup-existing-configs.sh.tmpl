#!/usr/bin/env bash

# Script de sauvegarde des configurations existantes
# Ex√©cut√© avant l'installation des dotfiles pour pr√©server les configurations actuelles

# Safer error handling
# Note: -e intentionally omitted to allow backup to continue even if some files fail
set -uo pipefail

# Couleurs pour l'affichage
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Variables
BACKUP_DIR="$HOME/.dotfiles-backup-$(date +%Y%m%d_%H%M%S)"
INTERACTIVE=true

# Fonction d'affichage
print_header() {
    echo -e "${BLUE}‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ${NC}"
    echo -e "${BLUE}‚îÇ${NC}  üíæ  ${CYAN}Sauvegarde des configurations existantes${NC}  üíæ   ${BLUE}‚îÇ${NC}"
    echo -e "${BLUE}‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ${NC}"
    echo ""
}

print_step() {
    echo -e "${BLUE}‚ñ∂${NC} $1"
}

print_success() {
    echo -e "${GREEN} ${NC} $1"
}

print_info() {
    echo -e "${CYAN}‚ÑπÔ∏è${NC} $1"
}

print_warning() {
    echo -e "${YELLOW} ${NC} $1"
}

# Fonction de confirmation
confirm() {
    if [[ "$INTERACTIVE" == false ]]; then
        return 0
    fi
    
    local message="$1"
    echo -e "${YELLOW}‚ùì${NC} $message"
    read -p "Continuer? [Y/n] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Nn]$ ]]; then
        print_info "Sauvegarde ignor√©e par l'utilisateur"
        exit 0
    fi
}

# Fonction principale de sauvegarde
create_backup() {
    print_step "V√©rification des configurations existantes..."
    
    # Liste des fichiers et dossiers √† sauvegarder
    local items_to_backup=(
        "$HOME/.zshrc"
        "$HOME/.bashrc"
        "$HOME/.bash_profile"
        "$HOME/.profile"
        "$HOME/.gitconfig"
        "$HOME/.gitignore_global"
        "$HOME/.tmux.conf"
        "$HOME/.vimrc"
        "$HOME/.nvimrc"
        "$HOME/.aliases"
        "$HOME/.functions"
        "$HOME/.exports"
        "$HOME/.extra"
        "$HOME/.env"
        "$HOME/.config/starship.toml"
        "$HOME/.config/nvim"
        "$HOME/.config/tmux"
        "$HOME/.config/git"
        "$HOME/.config/zsh"
        "$HOME/.oh-my-zsh"
        "$HOME/.vim"
        "$HOME/.tmux"
        "$HOME/.ssh/config"
    )
    
    # V√©rifier s'il y a des fichiers √† sauvegarder
    local files_found=false
    local files_list=()
    
    for item in "${items_to_backup[@]}"; do
        if [[ -e "$item" ]]; then
            files_found=true
            files_list+=("$item")
        fi
    done
    
    if [[ "$files_found" == false ]]; then
        print_info "Aucune configuration existante d√©tect√©e"
        print_info "Installation propre - aucune sauvegarde n√©cessaire"
        return 0
    fi
    
    # Afficher les fichiers trouv√©s
    echo ""
    print_warning "Configurations existantes d√©tect√©es:"
    for file in "${files_list[@]}"; do
        if [[ -f "$file" ]]; then
            echo "  üìÑ $(basename "$file")"
        elif [[ -d "$file" ]]; then
            echo "    $(basename "$file")/"
        fi
    done
    echo ""
    
    # Demander confirmation
    confirm "Cr√©er une sauvegarde de ces configurations avant l'installation?"
    
    # Cr√©er le dossier de sauvegarde
    print_step "Cr√©ation de la sauvegarde dans $BACKUP_DIR"
    if ! mkdir -p "$BACKUP_DIR"; then
        print_error "Impossible de cr√©er le dossier de sauvegarde: $BACKUP_DIR"
        return 1
    fi
    
    # Sauvegarder chaque √©l√©ment
    local backup_count=0
    for item in "${files_list[@]}"; do
        local item_name=$(basename "$item")
        local backup_path="$BACKUP_DIR/$item_name"
        
        if [[ -f "$item" ]]; then
            if cp "$item" "$backup_path" 2>/dev/null; then
                echo "  üìÑ $item_name"
                ((backup_count++))
            else
                echo "     √âchec sauvegarde: $item_name"
            fi
        elif [[ -d "$item" ]]; then
            if cp -r "$item" "$backup_path" 2>/dev/null; then
                echo "    $item_name/"
                ((backup_count++))
            else
                echo "     √âchec sauvegarde: $item_name/"
            fi
        fi
    done
    
    # Cr√©er un fichier d'information sur la sauvegarde
    cat > "$BACKUP_DIR/BACKUP_INFO.txt" << EOF
# Sauvegarde des dotfiles - $(date)
# Cr√©√©e avant l'installation des dotfiles modernes

Date de cr√©ation: $(date)
Hostname: {{ .chezmoi.hostname }}
Utilisateur: {{ .chezmoi.username }}
OS: {{ .chezmoi.os }}
Nombre de fichiers sauvegard√©s: $backup_count

## Fichiers sauvegard√©s:
$(for file in "${files_list[@]}"; do echo "- $file"; done)

## Pour restaurer:
# Copiez les fichiers depuis ce dossier vers votre home:
# cp -r $BACKUP_DIR/* ~/

## Pour supprimer cette sauvegarde:
# rm -rf $BACKUP_DIR

## Emplacement de la sauvegarde:
$BACKUP_DIR
EOF
    
    # Sauvegarder aussi les informations syst√®me utiles
    echo "# Informations syst√®me au moment de la sauvegarde" > "$BACKUP_DIR/SYSTEM_INFO.txt"
    echo "Date: $(date)" >> "$BACKUP_DIR/SYSTEM_INFO.txt"
    echo "Shell actuel: $SHELL" >> "$BACKUP_DIR/SYSTEM_INFO.txt"
    echo "PATH actuel: $PATH" >> "$BACKUP_DIR/SYSTEM_INFO.txt"
    
    # Sauvegarder la liste des packages install√©s
    {{- if eq .chezmoi.os "darwin" }}
    if command -v brew &> /dev/null; then
        echo "# Packages Homebrew install√©s" > "$BACKUP_DIR/homebrew_packages.txt"
        brew list >> "$BACKUP_DIR/homebrew_packages.txt" 2>/dev/null || true
        brew list --cask >> "$BACKUP_DIR/homebrew_casks.txt" 2>/dev/null || true
    fi
    {{- else }}
    if command -v apt &> /dev/null; then
        echo "# Packages APT install√©s" > "$BACKUP_DIR/apt_packages.txt"
        apt list --installed >> "$BACKUP_DIR/apt_packages.txt" 2>/dev/null || true
    elif command -v pacman &> /dev/null; then
        echo "# Packages Pacman install√©s" > "$BACKUP_DIR/pacman_packages.txt"
        pacman -Q >> "$BACKUP_DIR/pacman_packages.txt" 2>/dev/null || true
    fi
    {{- end }}
    
    print_success "Sauvegarde cr√©√©e avec succ√®s!"
    echo ""
    print_info "üìç Emplacement: $BACKUP_DIR"
    print_info "  Fichiers sauvegard√©s: $backup_count"
    echo ""
    print_info "  Pour restaurer plus tard:"
    echo "   cp -r $BACKUP_DIR/* ~/"
    echo ""
    print_info "üóëÔ∏è Pour supprimer la sauvegarde:"
    echo "   rm -rf $BACKUP_DIR"
    echo ""
    
    # Cr√©er un alias pour faciliter la restauration
    echo "# Alias de restauration (ajoutez √† votre .zshrc si n√©cessaire)" > "$BACKUP_DIR/restore_alias.sh"
    echo "alias restore-dotfiles-backup='cp -r $BACKUP_DIR/* ~/'" >> "$BACKUP_DIR/restore_alias.sh"
    
    print_warning "IMPORTANT: Gardez ce chemin en s√©curit√©!"
    print_warning "La sauvegarde sera n√©cessaire si vous voulez restaurer vos anciennes configurations."
}

# Fonction principale
main() {
    # V√©rifier les arguments
    if [[ "${1:-}" == "--non-interactive" ]]; then
        INTERACTIVE=false
    fi
    
    print_header
    
    print_info "Cette √©tape sauvegarde vos configurations existantes avant l'installation"
    print_info "des nouveaux dotfiles. C'est une mesure de s√©curit√© recommand√©e."
    echo ""
    
    create_backup
    
    echo ""
    print_success "Sauvegarde termin√©e - Installation des dotfiles peut continuer"
    echo ""
}

# Gestion des signaux
trap 'echo ""; print_warning "Sauvegarde interrompue"; exit 130' INT TERM

# Ex√©cution
main "$@"